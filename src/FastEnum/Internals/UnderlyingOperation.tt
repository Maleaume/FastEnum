<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#
    var parameters = new[]
    {
        new { TypeName = "SByte",  CompatibleName = "sbyte" },
        new { TypeName = "Byte",   CompatibleName = "byte" },
        new { TypeName = "Int16",  CompatibleName = "short" },
        new { TypeName = "UInt16", CompatibleName = "ushort" },
        new { TypeName = "Int32",  CompatibleName = "int" },
        new { TypeName = "UInt32", CompatibleName = "uint" },
        new { TypeName = "Int64",  CompatibleName = "long" },
        new { TypeName = "UInt64", CompatibleName = "ulong" },
    };
#>
// <auto-generated>
// This .cs file is generated by T4 template. Don't change it. Change the .tt file instead.
// </auto-generated>
using System; 
using System.Runtime.CompilerServices;
 
namespace FastEnumUtility.Internals
{
       /// <summary>
    /// Provides underlying type specified operation interface.
    /// </summary>
    /// <typeparam name="T">Enum type</typeparam>
    internal interface IUnderlyingOperation<T>
        where T : struct, Enum
    {
        bool IsContinuous { get; }
        bool IsDefined(ref T value);
        bool TryParse(string text, out T result);
        Member<T> GetMember(ref T value);
    } 

<# foreach (var x in parameters) { #>
    /// <summary>
    /// Provides <#= x.CompatibleName #> specified operation.
    /// </summary>
    /// <typeparam name="T">Enum type</typeparam>
    internal class <#= x.TypeName #>Operation<T> : Operation<T, <#= x.CompatibleName #>>
        where T : struct, Enum
    {
        #region Inner Classes 
        private sealed class Continuous : Continuous<T, <#= x.CompatibleName #>>
        { 
            public Continuous(<#= x.CompatibleName #> min, <#= x.CompatibleName #> max, Member<T>[] members)
                : base(min, max, members) { }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public override ulong ComputeIndex(<#= x.CompatibleName #> val) => (ulong)(val - this.minValue);
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public override bool TryParse(string text, out <#= x.CompatibleName #> x) => <#= x.CompatibleName #>.TryParse(text, out x);
        } 

        private sealed class Discontinuous : Discontinuous<T, <#= x.CompatibleName #>>
        {  
            public Discontinuous(FrozenDictionary<<#= x.CompatibleName #>, Member<T>> memberByValue)
                : base(memberByValue) { }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public override bool TryParse(string text, out <#= x.CompatibleName #> x) => <#= x.CompatibleName #>.TryParse(text, out x);
        }
        #endregion
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        protected override ulong GetLength(<#= x.CompatibleName #> minValue, <#= x.CompatibleName #> maxValue) => (ulong)(maxValue - minValue);
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        protected override UnderlyingOperation<T, <#= x.CompatibleName #>> InstanciateContinuous(<#= x.CompatibleName #> minValue, <#= x.CompatibleName #> maxValue, Member<T>[] members)
            => new Continuous(minValue, maxValue, members);
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        protected override UnderlyingOperation<T, <#= x.CompatibleName #>> InstanciateDiscontinuous(FrozenDictionary<<#= x.CompatibleName #>, Member<T>> memberByValue)
            => new Discontinuous(memberByValue);
    } 
<# } #>
}
